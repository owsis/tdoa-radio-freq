#include "FilterIQ.h"
#include <cmath>

// Filter coefficients (diambil dari hasil MATLAB)
std::vector<float> get_filter_coeffs(int bandwidth_khz)
{
  switch (bandwidth_khz)
  {
  case 400:
    return {0.0010667, 0.00064337, -0.00027743, -0.0019646, -0.0035808, -0.0038614, -0.0019046, 0.00196, 0.0058755, 0.0071865, 0.0040369, -0.0030178, -0.010538, -0.013583, -0.0085763, 0.0038329, 0.01784, 0.024656, 0.017258, -0.0045429, -0.031738, -0.048475, -0.03881, 0.0050115, 0.076959, 0.15758, 0.22087, 0.24483, 0.22087, 0.15758, 0.076959, 0.0050115, -0.03881, -0.048475, -0.031738, -0.0045429, 0.017258, 0.024656, 0.01784, 0.0038329, -0.0085763, -0.013583, -0.010538, -0.0030178, 0.0040369, 0.0071865, 0.0058755, 0.00196, -0.0019046, -0.0038614, -0.0035808, -0.0019646, -0.00027743, 0.00064337, 0.0010667};
  case 200:
    return {0.0010626, 0.0012977, 0.0019179, 0.0025603, 0.0031331, 0.0035283, 0.0036374, 0.0033685, 0.0026667, 0.0015318, 3.0084e-05, -0.0017015, -0.0034644, -0.0050168, -0.006103, -0.0064915, -0.0060152, -0.0046084, -0.0023332, 0.00060704, 0.0038759, 0.0070339, 0.0095876, 0.011053, 0.011029, 0.0092746, 0.0057577, 0.00070488, -0.0053994, -0.011833, -0.017702, -0.022027, -0.023857, -0.02239, -0.017082, -0.0077424, 0.005412, 0.021745, 0.040239, 0.059576, 0.078261, 0.094771, 0.10771, 0.11596, 0.11879, 0.11596, 0.10771, 0.094771, 0.078261, 0.059576, 0.040239, 0.021745, 0.005412, -0.0077424, -0.017082, -0.02239, -0.023857, -0.022027, -0.017702, -0.011833, -0.0053994, 0.00070488, 0.0057577, 0.0092746, 0.011029, 0.011053, 0.0095876, 0.0070339, 0.0038759, 0.00060704, -0.0023332, -0.0046084, -0.0060152, -0.0064915, -0.006103, -0.0050168, -0.0034644, -0.0017015, 3.0084e-05, 0.0015318, 0.0026667, 0.0033685, 0.0036374, 0.0035283, 0.0031331, 0.0025603, 0.0019179, 0.0012977, 0.0010626};
  case 40:
    return {-0.00082992, -0.00081149, -0.0011658, -0.0015822, -0.0020509, -0.0025557, -0.0030736, -0.0035744, -0.0040217, -0.0043731, -0.0045819, -0.0045977, -0.0043696, -0.0038475, -0.0029856, -0.0017442, -9.2165e-05, 0.0019899, 0.0045075, 0.0074515, 0.010797, 0.014502, 0.018507, 0.02274, 0.027114, 0.03153, 0.035883, 0.040063, 0.043961, 0.047468, 0.050489, 0.052934, 0.054735, 0.055837, 0.056208, 0.055837, 0.054735, 0.052934, 0.050489, 0.047468, 0.043961, 0.040063, 0.035883, 0.03153, 0.027114, 0.02274, 0.018507, 0.014502, 0.010797, 0.0074515, 0.0045075, 0.0019899, -9.2165e-05, -0.0017442, -0.0029856, -0.0038475, -0.0043696, -0.0045977, -0.0045819, -0.0043731, -0.0040217, -0.0035744, -0.0030736, -0.0025557, -0.0020509, -0.0015822, -0.0011658, -0.00081149, -0.00082992};
  case 12:
    return {-0.00026219, 0.00044295, 0.00038045, 0.00042419, 0.00051952, 0.00064702, 0.00080017, 0.00097765, 0.0011797, 0.0014073, 0.0016615, 0.0019435, 0.0022541, 0.0025941, 0.0029643, 0.003365, 0.0037963, 0.0042581, 0.0047503, 0.0052721, 0.0058225, 0.0064005, 0.0070046, 0.0076332, 0.008284, 0.0089548, 0.009643, 0.010346, 0.01106, 0.011782, 0.01251, 0.013238, 0.013963, 0.014681, 0.01539, 0.016082, 0.016756, 0.017408, 0.018032, 0.018625, 0.019184, 0.019704, 0.020183, 0.020618, 0.021004, 0.021341, 0.021625, 0.021854, 0.022028, 0.022144, 0.022203, 0.022203, 0.022144, 0.022028, 0.021854, 0.021625, 0.021341, 0.021004, 0.020618, 0.020183, 0.019704, 0.019184, 0.018625, 0.018032, 0.017408, 0.016756, 0.016082, 0.01539, 0.014681, 0.013963, 0.013238, 0.01251, 0.011782, 0.01106, 0.010346, 0.009643, 0.0089548, 0.008284, 0.0076332, 0.0070046, 0.0064005, 0.0058225, 0.0052721, 0.0047503, 0.0042581, 0.0037963, 0.003365, 0.0029643, 0.0025941, 0.0022541, 0.0019435, 0.0016615, 0.0014073, 0.0011797, 0.00097765, 0.00080017, 0.00064702, 0.00051952, 0.00042419, 0.00038045, 0.00044295, -0.00026219};
  default:
    return {};
  }
}

int filter_iq(const std::vector<std::complex<float>> &signal_iq, std::vector<std::complex<float>> &filtered_signal, int signal_bandwidth_khz)
{
  auto b = get_filter_coeffs(signal_bandwidth_khz);

  if (b.empty())
  {
    std::cout << "Invalid bandwidth specified or no filtering applied!" << std::endl;
    return 1;
  }

  size_t N = b.size();
  size_t M = signal_iq.size();
  // std::vector<std::complex<float>> filtered_signal(M, 0);

  // FIR filtering (konvolusi sederhana)
  for (size_t n = 0; n < M; ++n)
  {
    for (size_t k = 0; k < N; ++k)
    {
      if (n >= k)
      {
        filtered_signal[n] += signal_iq[n - k] * b[k];
      }
    }
  }

  return 0;
}
